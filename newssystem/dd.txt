项目名称：全球新闻发布管理系统
起始时间：2023/11/21
结束时间：2023/12/2
db用的是json server开启项目中的db数据库中的db.json并使用8000端口号来模拟后端的数据

1.npm creat-react-app myapp 创建脚手架
2..module.css 加 import style 加 style.item 来标识类和对应id来只影响部分组件的css文件，这叫模块化css
3.终端npm安装sass模块 sass模块的加持可以让前面只适合类和id的拓展到标签之类的
4.反向代理配置可以解决跨域问题，因为整个项目实际上大部分还是在浏览器跑的
5.npm安装axios用于http请求
6.react中内置了一个开发时候可以用的反向代理，按照官方文件配置即可设置一台反向代理服务器：src文件夹下建立setupProxy.js。然后复制一段代码，安装http-proxy-middleware模块，本质是把访问的跨域路由中的域名删掉，只写文件路由，然后在配置文件中，访问到这个文件路由的一级路由的时候，target里写上目标域名，也就是react会自动代理一台服务器帮你去取文件到本机，然后你自己访问就没有跨域限制了，写完记得重启服务器
7."C端"（Consumer端）指的是面向普通消费者的客户群体，"B端"（Business端）指的是面向企业或商业用户的客户群体
8.react万物皆组件，路由 本质也可以是组件，另外路由应该单独建个文件夹来管理
9.npm下载react-router-dom
10. HashRouter路由组件 ：使用 URL 中的哈希（#）来管理路由。http://example.com/#/path/to/page 。这种方式在旧版浏览器中具有良好的兼容性； BrowserRouter ：使用 HTML5 的 History API 来管理路由。在使用  BrowserRouter  时，URL 中的路由信息会被放置在 URL 的路径部分http://example.com/path/to/page，需要服务器的支持，因为它会修改浏览器的历史记录
11.react-router-dom@5和现在的@6版本还是有区别的，目前只会@5的使用，Switch也只有5的版本有，可以只匹配一个
12.路由拦截的一种方式可以是render 函数里面用三目运算符，验证失败就重定向redirect
13.箭头函数要不你就直接写，要不写了大括号就要写return，不要又写大括号又不写return
14.文件夹名字小写，组件名字大写
15.默认是模糊匹配 exact是精确匹配 “/”对于这种
16.直接引入antd组件库完成页面的基本布局，只要antd用的熟，前端的所有组件库都熟悉了
17.antd组件中可能会让某些元素不能撑开，这个时候可以设置下父元素height:100%就行了
18.组件的属性直接放着就相当于true了
19.二级嵌套菜单这种竟然可以数组map遍历的时候用到递归
20.组件的属性穿透可以用高阶组件withrouter
21.onClick事件接受一个function，这个function可以是箭头函数，但是它的参数必须是只有一个代表事件的e，至于怎么传入第二个参数，有两种写法，一个是把这个参数定义在同一个函数内即可，另一种呢是箭头函数的函数体内传入这个参数
22.json-server是一款 json 数据服务器，它运行 Express 服务器，可以对json文件、js脚本生成的json数据、远程json数据进行restful风格的增删改查操作，通过指定一个json文件作为api数据源，可以进行分页、排序、关联查询、范围查询等各种查询操作，是一套完整的模拟 REST API 接口
23.查看端口占用 命令行 netstat -ano | findstr :3000 然后看最后一位pid，然后任务管理器，详细信息那里找一下
24.小小的json-server竟然也可以表连接关联，apiId   _embed向下找（关联我的）  _expand向上找（我关联的）apis apiId _embed=api _expand=api
25.antd里的menu组件里的item从后端拿回来的数据要进行一定的处理再放到item里面，可以写个处理函数在外面，常用的数组处理函数有filter和map
26.antd menu里面selectedKeys，openKeys和defaultselectedkeys，defaultopenKeys是常见的属性操作，一般后者这种加了个default的属性代表着这个menu的非受控属性，只改变一次，后面是操作不了的，而没加的可以配合usestate可以做到受控，这里操作也挺有意思的，可以看一下写的操作
27.删除除了页面的同步状态，也要后端同步。实际上是有两种方案的，可以是后端直接同步，然后再发送一次请求，也可以是页面同步，同时后端同步少发送一次请求
28.rfc：useState这个hook改变的时候，这个App函数内部都会重新走一遍，只是其他hooks比如useeffects这种要看情况，看依赖有没有改变，其余的包括return之前的，return整个div中嵌套的jsx都会走一遍。但是走完之后才会去对比它渲染的部分用到state的部分，他会对比这部分，渲染的虚拟树与之前的进行一个对比，用diff算法进行对比，最后渲染页面的时候只进行局部渲染，从而起到一个高效，是局部渲染，不是局部执行，只要props或者state改变了，整个函数都会重新执行一遍
29.table啊list啊，antd这种都是要key的，数据没哟的话，找找antd文档看看有没有直接设置key的函数，比如rowKey，不着急改拿回来的数据  
30.default属性都是非受控属性，只受第一次更改
31.forwardref是用来做组件的穿透引用的  高阶引用 配合父组件的useref与内部的ref属性进行使用
32.以 use 开头的函数被称为 Hook
33.不能在useEffect中的回调函数中使用setdata的同时，依赖项使用data，这样会造成无限循环
34.异步执行的步骤可以放在settimeout中同步执行，给0ms也无所谓的，promise也可以用来解决
35.对象或者数组的扁平化处理
36.常见的hooks要学一下
37.redux和最新的routerv6也要学一下
38.useEffect如果没有写依赖的情况下，是默认每次组件渲染的饿时候都会执行一遍的，如果写了依赖，[]即是空，也就是只在第一次挂载的时候渲染一次，如果里面有变量，就是第一次挂载执行一次，以后每次相关变量改变的时候会执行一遍
39.props.match.params路由的信息	
40.时间库可以用moment，格式化显示yyyy-mm-dd hh:mm:ss 这种
41.使用某些库遇到执行不了的时候，可以关键字edge搜索一下，或者抄的示例中一行行的注释掉中阿出错的哪一行，然后在直接用示例的看一下可行不，如果不可行，就是库有问题，百度一下或者看说明文档，如果不是就typeof一下看你的和它的传入的参数的类型一样吗，这次找出的不是参数的类型问题，而是传入的参数的字符串前后有空字符
42.对象类型还是蛮重要的，有时候你usestate那里给的是个空数组的话，你后面set的是字符串，在进行某些处理的时候，很有可能因为初始的时候没set，是个数组类型，但是用到了字符串的方法，就会报一些is not a function之类的错误
43.一般来说，实现页面的功能基本都是，组件的具体使用，当前页面的改变（也就是当前组件的状态），发送给后端
44.数据一般都是放在后端的，每次取数据尽量从后端获取，前端只是存一些组件的状态即可
45.箭头函数，要不你写一行的不要加return不要加大括号，要不你加了大括号就一定要写return
46.axios拦截也经常用的，请求之前做什么，之后做什么
47.useeffect依赖里面还是要写点东西的，比如一个空数组，这样它不会每次渲染或者更新后执行一遍，而是第一次渲染才执行一遍
48.useeffect的返回值是一个回调函数来的，里面可以放组件销毁时候执行的步骤
49.可视化库除了antd体系的还有百度体系的echarts




当键盘放后一点，手肘处能够垂直或者大于九十度的时候打字的速度会快起来
antd
pageheader
select
form
步骤条
下拉列表
lodash






